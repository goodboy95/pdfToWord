# 03_数据结构与IR规范

## 3.1 文档目的

本文件定义本项目的**中间表示（IR, Intermediate Representation）**的数据结构与约束规范，用于连接：

* PDF/图像处理模块（OpenCV 表格结构、页裁切等）
* Gemini 识别模块（表格单元格文字、正文段落）
* Word 生成模块（OpenXML 写入）

目标是让系统具备：

* **可校验**（结构一致性、合并单元格合法性、乱码过滤）
* **可重试**（块级失败重跑）
* **可调试**（保留 bbox、可导出 JSON 样例）
* **可扩展**（未来加多栏/脚注/页眉页脚文本等不破坏旧数据）

---

## 3.2 术语与坐标体系

### 3.2.1 坐标系定义

本项目涉及多种图像来源与裁切变换，统一采用如下坐标体系：

* **像素坐标（Pixel）**：`(x, y, w, h)`，以图像左上角为原点 `(0,0)`，单位像素
* **PageImage 坐标**：指 PDF 渲染后的整页图片
* **CroppedPage 坐标**：指应用了页眉/页脚裁切后的页图；IR 中所有 bbox 默认基于 CroppedPage
* **TableImage 坐标**：表格裁剪图；其内部单元格 bbox 坐标以表格裁剪图左上角为原点

### 3.2.2 关键约定

* IR 中 `PageIr.WidthPx/HeightPx` 为 **裁切后页图**大小
* `BlockIr.BBox`（若存在）为 **裁切后页图坐标**
* `TableBlockIr.TableBBox` 为表格在裁切页图中的 bbox
* `TableCellIr.BBox`（若存在）为单元格在 **表格裁剪图**中的 bbox（便于调试与回填）

---

## 3.3 IR 顶层结构概览

IR 的最小可用版本由三层组成：

1. `DocumentIr`：整份文档
2. `PageIr`：按页组织，保持分页一致
3. `BlockIr`：页内按阅读顺序排列的块（段落块/表格块）

### 3.3.1 设计原则

* **阅读顺序为第一原则**：`PageIr.Blocks` 必须按阅读顺序排序（主要按 y，其次按 x）
* **每页独立**：默认不做跨页表格合并（后续可扩展）
* **结构与文本分离**：表格结构由算法产生，文本由 Gemini 回填
* **保留调试信息**：bbox、来源、置信度（可选）用于诊断与优化

---

## 3.4 C# 类型定义（规范版）

> 说明：字段名可按你团队 C# 命名规范调整；JSON 序列化字段名建议使用 snake_case 或 camelCase 统一，本文以 C# PascalCase + JSON camelCase 为推荐（实现层可用 `JsonPropertyName` 控制）。

### 3.4.1 DocumentIr

```csharp
public sealed class DocumentIr
{
    public string Version { get; set; } = "1.0";
    public DocumentMeta Meta { get; set; } = new();
    public List<PageIr> Pages { get; set; } = new();
}
```

#### DocumentMeta（建议）

```csharp
public sealed class DocumentMeta
{
    public string SourcePdfPath { get; set; } = "";
    public DateTime GeneratedAtUtc { get; set; } = DateTime.UtcNow;

    // 用户配置快照（便于复现问题）
    public ConvertOptionsSnapshot Options { get; set; } = new();
}
```

#### ConvertOptionsSnapshot（建议）

```csharp
public sealed class ConvertOptionsSnapshot
{
    public int Dpi { get; set; } = 300;
    public string PageRange { get; set; } = ""; // 原始输入
    public HeaderFooterRemoveMode HeaderFooterMode { get; set; } = HeaderFooterRemoveMode.None;
    public double HeaderPercent { get; set; } = 0.06;
    public double FooterPercent { get; set; } = 0.06;
    public PageSizeMode PageSizeMode { get; set; } = PageSizeMode.FollowPdf; // 或 A4
}
```

枚举建议：

```csharp
public enum HeaderFooterRemoveMode { None, RemoveHeader, RemoveFooter, RemoveBoth }
public enum PageSizeMode { A4, FollowPdf }
```

---

### 3.4.2 PageIr

```csharp
public sealed class PageIr
{
    public int PageNumber { get; set; }            // 1-based
    public int OriginalWidthPx { get; set; }       // 渲染后整页图宽
    public int OriginalHeightPx { get; set; }      // 渲染后整页图高

    public int WidthPx { get; set; }               // 裁切后页图宽
    public int HeightPx { get; set; }              // 裁切后页图高

    public CropInfo Crop { get; set; } = new();    // 裁切信息（便于复现）
    public List<BlockIr> Blocks { get; set; } = new();
}
```

#### CropInfo

```csharp
public sealed class CropInfo
{
    public HeaderFooterRemoveMode Mode { get; set; } = HeaderFooterRemoveMode.None;
    public int CropTopPx { get; set; } = 0;
    public int CropBottomPx { get; set; } = 0;
}
```

---

### 3.4.3 BlockIr（抽象基类）

```csharp
public abstract class BlockIr
{
    public abstract string Type { get; }           // "paragraph" / "table"
    public BBox? BBox { get; set; }                // 以裁切页图为坐标；段落块可为空
    public BlockSource Source { get; set; } = new();
}
```

#### BlockSource（建议）

用于追踪该块的来源、重试次数等：

```csharp
public sealed class BlockSource
{
    public string Producer { get; set; } = "";     // "GeminiText", "OpenCvTable+GeminiCells" 等
    public int Attempt { get; set; } = 1;          // 第几次尝试（重试+1）
    public string? DebugId { get; set; }           // 可选：用于关联日志/诊断包
}
```

#### BBox

```csharp
public readonly record struct BBox(int X, int Y, int W, int H)
{
    public int Left => X;
    public int Top => Y;
    public int Right => X + W;
    public int Bottom => Y + H;
}
```

---

### 3.4.4 ParagraphBlockIr

```csharp
public sealed class ParagraphBlockIr : BlockIr
{
    public override string Type => "paragraph";

    public ParagraphRole Role { get; set; } = ParagraphRole.Body;
    public string Text { get; set; } = "";         // 允许包含 '\n' 表示段内换行
}
```

枚举建议：

```csharp
public enum ParagraphRole { Title, Body }
```

文本规范：

* `Text` 必须为 UTF-16 有效字符串
* 允许 `\n`（段内换行）
* 不允许包含大量不可见控制字符（详见 3.8）

---

### 3.4.5 TableBlockIr

```csharp
public sealed class TableBlockIr : BlockIr
{
    public override string Type => "table";

    // 表格在裁切页图上的位置（用于排序与调试）
    public BBox TableBBox { get; set; }

    // 表格的列数（结构基准）
    public int NCols { get; set; }

    public List<TableRowIr> Rows { get; set; } = new();

    // 可选：表格结构来源信息
    public TableStructureMeta StructureMeta { get; set; } = new();
}
```

#### TableStructureMeta（建议）

```csharp
public sealed class TableStructureMeta
{
    public string Engine { get; set; } = "OpenCV";
    public double? LineScore { get; set; }         // 可选：线条密度评分
    public int? DetectedCellCount { get; set; }
}
```

---

### 3.4.6 TableRowIr / TableCellIr

```csharp
public sealed class TableRowIr
{
    public List<TableCellIr> Cells { get; set; } = new();
}

public sealed class TableCellIr
{
    public string Text { get; set; } = "";         // OCR 结果，允许空串
    public int Rowspan { get; set; } = 1;          // >=1
    public int Colspan { get; set; } = 1;          // >=1

    // 可选：用于回填与调试
    public BBox? CellBBoxInTableImage { get; set; } // 坐标基于表格裁剪图
    public string? CellId { get; set; }             // 与 Gemini 回填结果对应
}
```

---

## 3.5 JSON 序列化规范（对外/诊断包用）

IR 建议支持导出为 JSON，便于：

* 保存诊断包
* 回归测试（比较结构差异）
* 跨语言验证

### 3.5.1 版本与兼容

* `DocumentIr.Version` 必须存在
* 新增字段应保持向后兼容（旧程序忽略未知字段）
* 不允许删除或改变已有字段语义（除非升级主版本）

### 3.5.2 字段命名

建议 JSON 使用 camelCase：

* `pageNumber`, `widthPx`, `tableBBox`, `nCols`, `rowspan`...

实现建议：在 C# 使用 `JsonPropertyName` 显式绑定，以免重构导致协议破坏。

---

## 3.6 阅读顺序与排序规则（必须满足）

### 3.6.1 PageIr.Blocks 排序规范

块的排序用于写入 Word 的顺序，必须尽量符合阅读顺序：

1. 按 `BBox.Top` 升序
2. 若 `Top` 距离小于阈值（同一水平带），按 `BBox.Left` 升序
3. `BBox` 缺失的段落块（例如 Gemini 只输出 paragraphs）：

   * 默认将段落块视为占据整页剩余区域，可将其 `BBox` 设为整页（推荐）
   * 或在排序时将无 BBox 的段落块放在所有表格块之间：不推荐（易错序）

建议：正文段落块也给一个估计 bbox（例如整页），并在表格区域被 mask 后自然只剩“非表格正文”，这样排序更直观。

### 3.6.2 表格块与正文块的关系

* 若表格检测可靠：页面的 blocks 应表现为“正文段落块 + 表格块 + 正文段落块...”的交替结构
* MVP 阶段允许正文仅有 1 个 paragraph block（整页正文），在排序时置于所有表格块之前或之后会造成错序，因此推荐：

  * 正文识别输出也按 y 坐标分段（Gemini 输出多个段落），并给每段一个 bbox（进阶）
  * 或采用“表格区域 mask + Gemini 返回段落文本”并将其视为贯穿页的正文块，再由写入策略在表格前后插入（复杂，不推荐）

本项目建议：**MVP 用“单正文块”也可，但写入时将表格按 bbox.y 插入正文中会比较难**。因此在 IR 层建议支持“多段落块”，让正文也有多个块（Gemini 可输出 paragraphs 数组）。

---

## 3.7 表格结构合法性规则（强制校验）

### 3.7.1 基本规则

对 `TableBlockIr` 必须满足：

* `NCols >= 1`
* `Rows.Count >= 1`
* 对每个 `cell`：

  * `Rowspan >= 1`
  * `Colspan >= 1`
* 每行的“展开列数”必须等于 `NCols`

**展开列数**定义：对一行内 `Cells`，求和 `Colspan`，结果必须等于 `NCols`。
（注意：这是行内规则；rowspan 的影响在纵向合并时处理）

### 3.7.2 rowspan/colspan 越界检查（基于行列边界）

在抽象 IR 中没有显式的 `NRows`，但可由 `Rows.Count` 推导；对每个主单元格：

* rowspan 不得使其覆盖超过 `Rows.Count`
* colspan 不得使其覆盖超过 `NCols`

### 3.7.3 结构占位矩阵（owner matrix）一致性

为写入 OpenXML，最终会构造 `owner[r,c]`：

* 每个 (r,c) 必须被唯一主单元格覆盖
* 不允许出现空洞（未覆盖格）或多重覆盖（冲突覆盖）

IR 校验建议至少保证可以构造出无冲突的 owner matrix；若冲突，则该表格应触发重试或降级。

---

## 3.8 文本规范与乱码过滤

### 3.8.1 允许字符

* 中文、英文、数字、常见标点、空格、换行 `\n`、制表符 `\t`（谨慎使用）
* 允许全角/半角混用（保持原样）

### 3.8.2 不推荐/禁止字符

为避免 Word 中出现“乱码块”或不可见字符导致排版异常，建议过滤：

* ASCII 控制字符（0x00–0x08, 0x0B–0x0C, 0x0E–0x1F）
* 大量的替换字符 `�`（U+FFFD）超过阈值时视为识别失败
* 连续重复的无意义字符（可选规则，如超过 N 个相同符号）

过滤策略：

* 默认：移除不可见控制字符
* 若移除后文本为空且原本非空：标记该块质量低，可触发重试（由策略模块决定）

---

## 3.9 诊断与可追踪字段（建议）

为支持“预览与定位问题”，建议在 IR（或旁路结构）里保留：

* `PageIr.Crop`：裁切像素
* `TableBlockIr.TableBBox`：表格位置
* `TableCellIr.CellBBoxInTableImage`：单元格位置
* `BlockSource.Producer/Attempt/DebugId`：来源与重试次数
* （可选）`Confidence`：

  * 如果 Gemini 能提供置信度则记录；否则可记录“启发式质量评分”（如字符比例、是否含异常字符）

> 这些字段对最终 docx 输出不是必须，但对定位“表格分割错/裁切删了正文/某页输出怪”非常重要。

---

## 3.10 IR 与模块输入输出对接（映射关系）

### 3.10.1 TableEngine → TableBlockIr

* 输入：裁切后页图 + 预处理结果
* 输出：

  * `TableBBox`（页坐标）
  * `NCols`
  * `Rows/Cells`（仅结构，Text 为空或占位）
  * `CellBBoxInTableImage`（可选，强烈推荐用于 Gemini 回填）

### 3.10.2 Gemini（表格）→ TableCellIr.Text

* 输入：表格裁剪图 + cell bbox 列表（含 cellId）
* 输出：`(cellId, text)`
* 回填：按 cellId 匹配写入 `Text`

### 3.10.3 Gemini（正文）→ ParagraphBlockIr

* 输入：遮罩表格后的页图
* 输出：paragraphs 数组（建议含 role）
* 映射：每个 paragraph 生成一个 `ParagraphBlockIr`

  * 若未提供 bbox，可暂时为空（但排序策略需处理；建议后续扩展提供段落 bbox）

### 3.10.4 DocxWriter ← IR

* 输入：DocumentIr + 写入选项（页面尺寸模式、字体等）
* 输出：docx

---

## 3.11 版本演进建议（可选）

### v1.0（当前目标）

* 支持 paragraph + table 两类 block
* 表格结构稳定（rowspan/colspan）
* 保留分页
* 页眉页脚裁切

### v1.1（可选增强）

* 为 paragraphs 增加 bbox（更精准插入表格与正文位置）
* 增加 `ListBlock`（项目符号/编号列表）区分
* 增加 `HeaderFooterText`（若未来希望保留但可选去除）

---

## 3.12 示例（简化 IR 样例）

```json
{
  "version": "1.0",
  "meta": {
    "sourcePdfPath": "C:\\docs\\sample.pdf",
    "generatedAtUtc": "2025-12-27T03:00:00Z",
    "options": {
      "dpi": 300,
      "pageRange": "1,3,5-10",
      "headerFooterMode": "RemoveBoth",
      "headerPercent": 0.06,
      "footerPercent": 0.06,
      "pageSizeMode": "A4"
    }
  },
  "pages": [
    {
      "pageNumber": 1,
      "originalWidthPx": 2480,
      "originalHeightPx": 3508,
      "widthPx": 2480,
      "heightPx": 3088,
      "crop": { "mode": "RemoveBoth", "cropTopPx": 210, "cropBottomPx": 210 },
      "blocks": [
        { "type": "paragraph", "role": "Title", "text": "项目报告" },
        {
          "type": "table",
          "tableBBox": { "x": 120, "y": 480, "w": 2240, "h": 900 },
          "nCols": 4,
          "rows": [
            { "cells": [
              { "text": "姓名", "rowspan": 1, "colspan": 1 },
              { "text": "张三", "rowspan": 1, "colspan": 1 },
              { "text": "部门", "rowspan": 1, "colspan": 1 },
              { "text": "研发", "rowspan": 1, "colspan": 1 }
            ] }
          ]
        },
        { "type": "paragraph", "role": "Body", "text": "以上为基本信息。\n以下为说明内容……" }
      ]
    }
  ]
}
```

---

## 3.13 本文档的验收点（对实现的约束）

实现 IR 与相关模块时必须满足：

1. 能稳定构造 `DocumentIr → PageIr → Blocks`
2. 表格结构满足 3.7 的合法性规则，可构造 owner matrix
3. 文本过滤规则执行，避免 Word 出现大量不可见乱码
4. 坐标体系一致：bbox 均基于裁切后页图；单元格 bbox 基于表格裁剪图
5. IR 导出为 JSON 后可用于复现与回归测试
