# 07_表格检测与单元格分割算法

## 7.1 文档目的

本文档给出在“**表格均有边框线**、且**经常合并单元格**”的前提下，一套可在 .NET + OpenCvSharp 中落地的表格处理算法方案，覆盖：

* 在页图中检测表格区域（table bounding boxes）
* 在表格区域中分割单元格并推断行列网格
* 计算每个单元格的 `rowspan/colspan`
* 生成符合 IR 规范的 `TableBlockIr`（结构稳定，可校验）
* 提供参数策略（与 DPI/图像尺寸联动）、失败处理与降级建议

> 设计目标：让“表格结构（含合并）”由确定性算法产出，Gemini 只做单元格文字识别回填，从而显著提升稳定性与可控性。

---

## 7.2 输入输出定义

### 输入

来自《06》的 `PageImageBundle`：

* `ColorForGemini`：裁切+可选 deskew 后的彩色图（可用于可视化与裁剪）
* `BinaryForTable`：裁切+可选 deskew 后的二值图（用于线条提取）
* `CroppedSizePx`：宽高
* 裁切信息：`CropInfo`（用于写入 IR）

### 输出

对每页输出：

* `List<TableDetection>`：每个表格的检测结果

  * `TableBBox`：表格在裁切页图中的 bbox
  * `TableImage`：表格裁剪图（彩色/灰度，供 Gemini OCR）
  * `Grid`：表格结构（行列边界、单元格列表、rowspan/colspan）
  * `Debug`：可选（线条 mask、交点图等）

并可转换为 IR：

* `TableBlockIr`（结构部分：`NCols/Rows/Cells(rowspan/colspan)`）
* 单元格文字后续由 Gemini 回填

---

## 7.3 总体流程（推荐实现）

对每页：

1. **线条提取**：从 `BinaryForTable` 分别提取水平线与竖直线 mask
2. **表格区域检测**：合并线条 mask，找轮廓生成候选 bbox，过滤 + 合并得到最终表格 bbox 列表
3. 对每个表格 bbox：

   1. 裁剪表格区域（从彩色图与二值图各裁一份）
   2. **网格边界提取**：得到列边界 X 列表、行边界 Y 列表（聚类去抖）
   3. **单元格识别**：在表格内部找“单元格连通域”，得到单元格 bbox
   4. **rowspan/colspan 推断**：将单元格 bbox 映射到行列区间，计算跨行跨列
   5. **结构组装与校验**：生成 `TableGrid`，校验展开列数一致、无冲突覆盖
4. 输出表格结构与 bbox，供后续：

   * Gemini 表格文字回填（表格图 + cell bbox 列表）
   * 页面文本识别遮罩（mask 表格 bbox）

---

## 7.4 线条提取（Line Extraction）

### 7.4.1 前提

* 输入 `BinaryForTable` 应尽量呈现：**线条与文字为黑、背景为白**（若相反需先反相）
* 表格有边框线 → 形态学提取线条非常有效

### 7.4.2 提取方法

对二值图 `bin`：

1)（可选）先做一次轻微开/闭运算，去掉小噪声点
2) 水平线提取：

* 使用水平结构元素 `kernelH = (w / k, 1)` 做形态学开运算：

  * `erode` → `dilate`

3. 竖直线提取：

* 使用竖直结构元素 `kernelV = (1, h / k)` 做形态学开运算

#### kernel 尺寸建议（随图像宽高自适应）

设裁切页图宽 `W`、高 `H`：

* `kernelH.width = max(20, W / 30)`，`kernelH.height = 1`
* `kernelV.height = max(20, H / 30)`，`kernelV.width = 1`

> 对 300DPI 的 A4 常见宽 ~ 2480px，高 ~ 3508px，`W/30 ≈ 82`，基本合理。可在预览中观察线条是否断裂/是否把文字当线条抽走。

### 7.4.3 线条增强（可选）

如果线条较细或断裂：

* 对水平线 mask 做一次 `dilate`（轻微）
* 对竖直线 mask 做一次 `dilate`（轻微）

注意：不要过度膨胀，否则相邻线条会黏连导致后续边界聚类困难。

---

## 7.5 表格区域检测（Table BBox Detection）

### 7.5.1 候选区域生成

将水平线与竖直线 mask 合并：

* `gridMask = horizontalMask OR verticalMask`

对 `gridMask`：

* 做一次 `dilate`（把断裂连接起来，核可用 3x3 或 5x5）
* `findContours` 找轮廓
* 对每个轮廓求 `boundingRect` 得候选 bbox

### 7.5.2 候选过滤规则（建议）

过滤掉噪声：

* 面积阈值：`bboxArea < (W*H*0.005)`（页面积的 0.5% 以下可视为噪声，视样本调整）
* 最小边长：`bbox.w < 150` 或 `bbox.h < 80`（300DPI 下经验值）
* 线条密度：在 bbox 内 `gridMask` 黑像素占比低于阈值则丢弃（可选增强）

### 7.5.3 相邻框合并（重要）

表格线有时会被分成多个相邻轮廓，需要合并：

* 使用 IoU 或 “距离阈值合并”：

  * 若两个 bbox 的水平/垂直间距 < `mergeGapPx`（如 10~20px）且重叠比例高，则合并成更大的 bbox
* 可重复合并直到收敛

输出：`List<TableBBox>`（按 TopY 排序）

---

## 7.6 表格内部网格边界提取（Row/Col Boundaries）

目标：得到近似的网格线坐标列表：

* `colLinesX = [x0, x1, ..., xn]`（含左右边界）
* `rowLinesY = [y0, y1, ..., ym]`（含上下边界）

> 这一步是推断 rowspan/colspan 的基础。

### 7.6.1 从线条 mask 取投影（推荐稳法）

在表格裁剪区域内：

* `verticalMaskTable`：竖直线 mask 的裁剪部分
* 对每个 x 列求和（列投影）：`sumX[x] = Σ verticalMaskTable[y,x]`

  * sumX 大的 x 表示存在竖直线
* 对 `sumX` 做阈值化，得到竖线“候选 x 集合”
* 将相邻 x（距离 < eps）聚类，取每簇均值作为竖线坐标

同理对水平线：

* `horizontalMaskTable` 做行投影 `sumY[y]`
* 阈值化 → 聚类 → 得到水平线坐标

### 7.6.2 阈值与聚类参数（随 DPI 调整）

* eps（聚类距离）：300DPI 建议 3~6px；400DPI 可 5~10px
* 阈值：

  * 可用 `sumX[x] > (tableHeight * t)`，t 如 0.3~0.6
  * 或根据 sumX 的分位数自适应（更鲁棒）

### 7.6.3 边界补齐

投影法可能漏掉最外框边界，建议：

* 强制加入 `x=0` 与 `x=tableWidth-1`
* 强制加入 `y=0` 与 `y=tableHeight-1`
* 然后整体排序去重

### 7.6.4 边界合法性检查

* `colLinesX.Count >= 2`（至少左右边界）
* `rowLinesY.Count >= 2`（至少上下边界）
* 相邻边界间距不应过小（如 < 5px 视为噪声，可合并/去掉）

若失败：

* 可对线条 mask 做更强 `dilate` 再试一次
* 再失败则该表格降级为“仅 bbox + 整表 OCR 不拆格”（见 7.10）

---

## 7.7 单元格分割（Cell Detection）

合并单元格频繁时，“交点法”容易被断线干扰；本项目推荐 **连通域/轮廓法**：

### 7.7.1 轮廓法原理

* 表格线构成封闭区域
* 将线条 mask 取反后，单元格内部是连通白块/黑块（取决于颜色）
* 对连通区域找轮廓，即可得到每个单元格区域

### 7.7.2 实现步骤（推荐）

在表格裁剪区域内：

1. 构造 “表格线图”：

* `gridMaskTable = horizontalMaskTable OR verticalMaskTable`

2. 适度膨胀，使线条闭合：

* `gridMaskTable = dilate(gridMaskTable, 3x3 或 5x5)`

3. 取反得到 “cellFill”：

* `cellFill = NOT(gridMaskTable)`

4. 去除外部背景：

* 在 `cellFill` 上进行 flood-fill 或用外轮廓剔除最大连通域（外背景）

5. `findContours(cellFill)` 找到单元格轮廓
6. 对每个轮廓求 `boundingRect` 得到 `cellBBox`

### 7.7.3 单元格 bbox 过滤

* 排除过小区域（噪声）

  * `cellBBox.w < minCellW` 或 `cellBBox.h < minCellH` 丢弃
  * min 值建议与表格整体尺寸相关：如 `minCellW = tableWidth * 0.02`
* 排除“几乎等于整张表格”的外背景（若未剔除成功）

输出：`List<CellBBox>`（坐标基于表格裁剪图）

---

## 7.8 rowspan / colspan 推断

### 7.8.1 核心思想

* `colLinesX` 划分出列区间 `[x[i], x[i+1])`
* `rowLinesY` 划分出行区间 `[y[j], y[j+1])`
* 单元格 bbox 覆盖了哪些区间 → 决定它跨了多少行/列

### 7.8.2 匹配规则

对每个 `cellBBox`：

1. 计算它在 x 方向覆盖的列索引范围：

* 找到 `left` 落在哪个列区间
* 找到 `right` 落在哪个列区间
* `colspan = rightIndex - leftIndex + 1`

2. y 方向同理：

* `rowspan = bottomIndex - topIndex + 1`

为增强鲁棒性，建议对 bbox 边界做小范围扩张或使用阈值容差：

* `leftXAdjusted = leftX + tol`
* `rightXAdjusted = rightX - tol`
  tol 可取 2~5px（300DPI）

### 7.8.3 生成行内 cell 顺序

为了形成 `Rows -> Cells[]`：

* 按 `cellBBox.Top` 聚类成行（容差：同一行 top 差 < epsY）
* 每行内按 `cellBBox.Left` 排序
* 然后计算 colspan 并确保该行的 colspan 总和 == NCols

其中 `NCols = colLinesX.Count - 1`

### 7.8.4 owner 矩阵校验（强制）

构造 `owner[r,c]`（r 行索引 0..R-1，c 列索引 0..NCols-1）：

* 对每个主单元格 (r0,c0) 覆盖范围：

  * `r in [r0, r0+rowspan)`
  * `c in [c0, c0+colspan)`
* 若任何格子已被占用，则发生冲突：

  * 表格结构不可信 → 触发重试/调整参数/降级

---

## 7.9 生成 IR 所需的 TableGrid

生成 `TableBlockIr` 的结构部分（文字暂空或占位）：

* `NCols = colLinesX.Count - 1`
* `Rows = rowGroups.Count`
* `Rows[i].Cells[j]`：

  * `Rowspan/Colspan`
  * `CellBBoxInTableImage`
  * `CellId`（建议：`p{page}_t{tableIndex}_r{r}_c{c}`）

> `CellId` 用于后续 Gemini 回填时稳定匹配，不依赖坐标浮动。

---

## 7.10 与 Gemini 表格文字回填的对接（关键接口）

为了减少请求次数，建议每张表格只调用 **一次** Gemini：

**输入：**

* 表格彩色裁剪图 `tableImage`
* cells 列表：`[{ id, x, y, w, h }]`

**输出：**

* `[{ id, text }]`

然后程序按 `id` 回填到 `TableCellIr.Text`。

> 注意：Gemini 的任务是“识别每个给定单元格里的文字”，不要让它推断结构。

---

## 7.11 参数策略（与 DPI 联动）

### 7.11.1 推荐默认（300DPI）

* 线提取 kernel：

  * `kernelH.width = max(20, pageWidth/30)`
  * `kernelV.height = max(20, pageHeight/30)`
* gridMask 膨胀核：3x3 或 5x5
* 边界聚类 eps：

  * `epsX = 4px`, `epsY = 4px`
* 单元格过滤：

  * `minCellW = tableWidth*0.02`
  * `minCellH = tableHeight*0.02`

### 7.11.2 200DPI / 400DPI 调整建议

* 200DPI：eps 取小一些（2~4），kernel 尺寸也相应变小
* 400DPI：eps 取大一些（6~10），避免同一条线被拆成多个簇

### 7.11.3 自动调参（可选）

若 `owner` 冲突过多或边界线数量明显不合理：

* 先增大 `dilate` 一次重新提取线
* 或降低投影阈值（让更多线进入候选）
* 或提高 minCell 过滤阈值（去掉噪声 cell）

---

## 7.12 失败处理与降级策略（本模块层面）

### 7.12.1 常见失败形态

* 表格 bbox 检测不到（线太淡/被遮挡）
* 边界线数量异常（漏线/断线导致 colLinesX 太少）
* 单元格轮廓过多（噪声造成碎片）
* owner 矛盾（线错位导致 cell 覆盖冲突）

### 7.12.2 本模块可执行的回退

对每张表格，按顺序尝试：

1. **增强线条闭合**：提高 `dilate` 强度重跑一次
2. **降低投影阈值**：让更多线进入边界候选
3. **放宽聚类 eps**：合并邻近线（减少重复线）
   若仍失败：
4. 降级：只输出 `TableBBox`，不拆单元格，交给后续策略决定：

   * 方案 A：Gemini 整表 OCR 输出“纯文本表格”（行用换行，列用 tab）
   * 方案 B：在 Word 中插入一张“图片表格”（不推荐，违背可编辑目标，但可作为最末回退）

> 具体降级写法在《09_结果校验_重试_降级策略》里定义，但模块需返回明确失败原因与调参建议。

---

## 7.13 调试与可视化建议（强烈建议实现）

为快速定位表格结构问题，建议提供可选调试输出：

* 在页图上绘制 `TableBBox` 框
* 在表格图上绘制：

  * `colLinesX`、`rowLinesY` 线
  * `cellBBox` 框
  * 每个 cellId 标注（小字）
* 输出关键 mask：

  * `horizontalMaskTable.png`
  * `verticalMaskTable.png`
  * `gridMaskTable.png`
  * `cellFill.png`

这些输出可用于：

* 用户在 UI 预览中调整 DPI/裁切比例
* 开发定位参数是否过强/过弱

---

## 7.14 建议的数据结构（实现层）

### TableDetection（示意）

```csharp
public sealed class TableDetection
{
    public BBox TableBBoxInPage { get; init; }
    public Bitmap TableImageColor { get; init; } = default!;
    public Mat TableBinary { get; init; } = default!;

    public List<int> ColLinesX { get; init; } = new(); // 0..width-1
    public List<int> RowLinesY { get; init; } = new(); // 0..height-1

    public List<CellBox> Cells { get; init; } = new(); // 含 cellId/bbox/rowspan/colspan
    public int NCols { get; init; }
    public int NRows { get; init; }

    public string? DebugId { get; init; }
}
```

### CellBox（示意）

```csharp
public sealed class CellBox
{
    public string Id { get; init; } = "";
    public BBox BBoxInTable { get; init; }
    public int Row { get; init; }
    public int Col { get; init; }
    public int Rowspan { get; init; } = 1;
    public int Colspan { get; init; } = 1;
}
```

---

## 7.15 本模块验收点

* 在典型样例（有边框线、含合并单元格）上：

  * 表格 bbox 检测准确（至少不漏主要表格）
  * 行列边界合理，NCols/NRows 不离谱
  * 单元格分割正确，不出现大量碎片噪声
  * rowspan/colspan 推断大体正确
  * owner 矩阵可构造且无冲突
* 调参后可明显改善（DPI、dilate、阈值）
* 调试输出能够直观显示失败原因（线断裂、漏线、噪声等）
