# 02_架构设计

## 2.1 文档目的

本文档描述本软件的整体架构设计，包括：

* 技术栈与分层结构（WPF + MVVM + .NET 8）
* 关键模块划分与职责边界
* 端到端执行流程（Job → Pages → Blocks）
* 并发、取消、重试、降级等运行机制
* 关键接口与数据流（PDF 渲染、OpenCV、Gemini、OpenXML）

---

## 2.2 技术栈与总体结构

### 平台与框架

* OS：Windows 10/11
* UI：WPF
* 运行时：.NET 8
* 图像处理：OpenCvSharp4
* PDF 渲染：PDFium（或其他能稳定输出 Bitmap 的渲染库）
* LLM/OCR：Gemini API
* Word 生成：Open XML SDK (`DocumentFormat.OpenXml`)

### 架构风格

* UI 采用 **MVVM**
* 核心处理采用 **Pipeline + Job Scheduler**（后台任务队列）
* 模块间通过 **接口抽象（Dependency Injection）** 解耦，便于替换实现（例如更换 PDF 渲染器）

---

## 2.3 逻辑分层（建议工程结构）

建议解决方案结构（可按你团队命名调整）：

* `Pdf2Word.App`（WPF UI）

  * Views / ViewModels / Controls
  * 依赖注入启动、配置加载、UI 资源
* `Pdf2Word.Core`（业务核心）

  * Job 模型、状态机、Pipeline 编排、重试降级策略
  * IR（中间表示）与校验
* `Pdf2Word.Infrastructure`（基础设施）

  * PDF 渲染（PdfRenderer）
  * 图像预处理、表格检测与单元格分割（OpenCvTableEngine）
  * Gemini 客户端（GeminiClient）
  * Docx 写入（OpenXmlDocxWriter）
  * 缓存与文件系统（TempStorage）
* `Pdf2Word.Tests`（测试）

  * 单元测试、集成测试、样例回归

> 原则：UI 层不直接调用 OpenCV/Gemini/OpenXML；一切由 Core 编排。

---

## 2.4 核心模块划分与职责

### 2.4.1 UI 模块（WPF）

职责：

* 采集用户输入参数（文件、页码范围、裁切选项、页面尺寸、DPI/并发）
* 展示进度、日志、预览
* 支持取消与导出结果

不应承担：

* 任何耗时处理（渲染、OpenCV、网络请求、docx 生成）
* 业务策略决定（重试、降级、排序）

### 2.4.2 Job 编排模块（Core）

职责：

* 解析页码范围，构建 Job
* 控制并发与调度（页级并发，表格识别策略）
* 管理取消令牌、失败策略
* 聚合每页 IR，生成 Document IR
* 调用 DocxWriter 生成最终输出

### 2.4.3 PDF 渲染模块（Infra: PdfRenderer）

职责：

* 获取 PDF 总页数
* 将指定页渲染为 Bitmap（按 DPI）
* 以统一坐标系/尺寸输出（供 OpenCV 使用）

设计要点：

* 渲染结果尽量不要常驻内存：可写入临时 PNG 再读取（十来页也可直接内存，但建议可配置）
* 每页渲染失败要可捕获并标记该页失败

### 2.4.4 图像处理与表格结构模块（Infra: TableEngine）

职责：

* 对页图进行预处理（灰度/增强/二值化/deskew）
* 检测表格 bbox（有边框线）
* 对每个表格 bbox：单元格分割、推断行列边界、计算 rowspan/colspan，生成 TableGrid
* 生成 mask 图（遮罩表格区域）供正文识别

设计要点：

* 输出应包含 bbox（用于排序、预览、调试）
* 表格结构输出必须可校验（例如列边界递增、rowspan/colspan 合法）

### 2.4.5 Gemini 客户端（Infra: GeminiClient）

职责：

* 将图片编码为请求体（Base64/多段）
* 按两类 prompt 调用：

  1. 表格文字回填（表格图 + cell bbox 列表 → cell text）
  2. 正文段落识别（遮罩后页图 → paragraphs）
* 处理超时、重试、错误分类
* 对返回内容做“基础结构校验”（至少 JSON 解析级别）

设计要点：

* 统一“强约束 JSON 输出”协议，失败可触发更强约束的 fallback prompt
* 限制并发（避免网络抖动和 API 限流）

### 2.4.6 IR 校验与合并模块（Core: IrBuilder + Validators）

职责：

* 将 TableEngine 结果 + Gemini 结果合并为 Page IR
* 按阅读顺序排序 blocks
* 校验 IR（表格展开列数一致、rowspan/colspan 越界检查、乱码过滤）
* 策略：失败重试/降级（仅对失败块）

### 2.4.7 Word 生成模块（Infra: OpenXmlDocxWriter）

职责：

* 根据 Document IR 生成 docx
* 支持页面尺寸模式：A4 或跟随 PDF
* 写入分页、段落样式、表格与合并单元格
* 设置中英文字体（EastAsia/Ascii）

设计要点：

* 合并单元格采用 owner 矩阵法避免 merge 顺序导致错位
* “像原文一样”的策略：优先保留分页、段落换行、表格结构

---

## 2.5 数据流与执行流程

### 2.5.1 高层流程（Job 级）

1. UI 收集参数 → 创建 `ConvertJobRequest`
2. Core 解析页码范围 → 得到 `TargetPages`
3. 初始化 Job（状态=Running）
4. 按页调度处理（并发 N）
5. 聚合所有 Page IR → 得到 Document IR
6. DocxWriter 输出 docx
7. 状态=Succeeded / Failed / Canceled

### 2.5.2 单页流程（PageTask）

对 Page i：

1. `PdfRenderer.Render(page=i, dpi=...)` → `pageImage`
2. `HeaderFooterCropper.Apply(pageImage, mode, headerPct, footerPct)` → `croppedImage`
3. `Preprocessor.Process(croppedImage)` → `preprocessed`（含二值图、deskew 后图等）
4. `TableEngine.DetectTables(preprocessed)` → `tableBBoxes[]`
5. 对每个表格：

   * `TableEngine.ExtractGrid(tableBBox)` → `TableGrid`（含 cell bbox、rowspan/colspan）
   * `GeminiClient.RecognizeTableText(tableImage, cells)` → cell texts
   * `TableGrid.ApplyTexts(cellTexts)`
   * `Validate(TableGrid)`，失败则重试/降级
6. `Masker.MaskTables(croppedImage, tableBBoxes)` → `textOnlyImage`
7. `GeminiClient.RecognizeParagraphs(textOnlyImage)` → `paragraphs`
8. `IrBuilder.BuildPageIr(paragraphs, tables, bboxes)` → `PageIr`
9. `Validate(PageIr)`，失败则按策略处理
10. 输出该页结果、上报进度

---

## 2.6 任务状态机与错误策略

### 2.6.1 状态机（建议）

* `Pending`：已创建未开始
* `Running`：处理中
* `Succeeded`：全部完成且 docx 生成成功
* `Failed`：关键步骤失败导致无法输出
* `Canceled`：用户取消

页级状态（可选更细）：

* `PagePending / PageRunning / PageSucceeded / PageFailed`

### 2.6.2 错误分层

* 可重试错误（Transient）：

  * Gemini 网络超时、JSON 格式不合法、偶发空结果
* 不可重试错误（Fatal）：

  * PDF 渲染失败（持续失败）
  * 文件写入失败（权限/路径）
  * 参数非法（页码范围解析失败且用户未修正）

### 2.6.3 重试与降级（架构层要求）

* 重试粒度：**块级**（表格块/正文块），而不是整页、整本
* 重试次数：默认 1 次（可配置）
* 降级策略（架构保证“至少可读”）：

  * 表格：结构保留但文本缺失 → 再不行则纯文本表格
  * 正文：无法分段则输出单段全文文本

> 这些策略的具体细节在《09_结果校验_重试_降级策略》中详述，但架构需预留接口与状态上报。

---

## 2.7 并发与线程模型

### 2.7.1 UI 与后台

* UI 线程只负责展示与交互，不执行任何耗时任务
* 后台处理在 Task/线程池执行
* 通过 `IProgress<T>` / 事件 / Reactive 流向 UI 汇报进度

### 2.7.2 并发策略（建议默认）

* 页级并发：默认 2（可选 1/2/4）
* 同页表格识别：

  * 方案 A（简化）：同页表格串行，减少并发压力
  * 方案 B（加速）：同页表格并行但总并发仍受全局 Semaphore 限制

推荐：采用 **全局并发控制**（SemaphoreSlim），对所有 Gemini 请求限流，例如最多 2~4 个并发请求，避免 API 限流与本机资源抖动。

### 2.7.3 取消机制

* UI 点击取消 → 触发 `CancellationTokenSource.Cancel()`
* Core 在每个阶段检查 token：

  * PDF 渲染前后
  * OpenCV 处理前后
  * 每个 Gemini 请求前
  * Docx 写入前
* 取消后：

  * 停止调度新页
  * 已完成页可保留中间产物（可选）
  * 输出状态为 Canceled

---

## 2.8 配置与依赖注入（DI）

### 2.8.1 配置项来源（建议）

* UI 表单参数（本次任务）
* 全局默认配置（本地配置文件）
* 运行时可覆盖（例如命令行参数，非必须）

关键配置项示例：

* DPI（默认 300）
* 页级并发（默认 2）
* Gemini 超时（默认 90s）
* 重试次数（默认 1）
* 页眉/页脚默认裁切比例（默认 6%/6%）
* 页面尺寸模式默认值（A4 或跟随 PDF）
* 临时目录路径与清理策略

### 2.8.2 DI 接口建议

（便于替换实现或做 mock 测试）

* `IPdfRenderer`
* `IImagePreprocessor`
* `ITableEngine`
* `IGeminiClient`
* `IIrValidator`
* `IDocxWriter`
* `ITempStorage`
* `ILogger`（或封装）

---

## 2.9 关键接口草案（仅架构级，细节在各模块文档）

### 2.9.1 Job 编排入口

* `Task<ConvertResult> ConvertAsync(ConvertJobRequest request, IProgress<JobProgress> progress, CancellationToken ct)`

### 2.9.2 PDF 渲染

* `int GetPageCount(string pdfPath)`
* `Bitmap RenderPage(string pdfPath, int pageIndex0Based, int dpi)`

### 2.9.3 表格引擎

* `PreprocessResult Preprocess(Bitmap image, PreprocessOptions opt)`
* `List<BBox> DetectTables(PreprocessResult prep)`
* `TableGrid ExtractGrid(PreprocessResult prep, BBox tableBox)`
* `Bitmap MaskTables(Bitmap image, IEnumerable<BBox> tableBoxes)`

### 2.9.4 Gemini

* `Task<TableTextResult> RecognizeTableTextAsync(Bitmap tableImage, IReadOnlyList<CellBox> cells, CancellationToken ct)`
* `Task<ParagraphResult> RecognizeParagraphsAsync(Bitmap pageImageMasked, CancellationToken ct)`

### 2.9.5 Word 写入

* `Task WriteAsync(DocumentIr doc, DocxWriteOptions opt, Stream output, CancellationToken ct)`

---

## 2.10 架构决策记录（ADR 简述）

### ADR-001：表格结构由 OpenCV 推断，Gemini 仅做文字回填

原因：合并单元格频繁，LLM 直接输出结构不稳定且难校验；OpenCV 对“有边框线”表格具有确定性优势。

### ADR-002：输出中间 IR（结构化表示）

原因：便于校验、重试、降级、调试与未来替换实现；避免直接耦合 Gemini 输出与 OpenXML 写入。

### ADR-003：分页策略一页一分隔

原因：更接近原 PDF 阅读体验；降低跨页合并复杂度；便于定位错误页。

### ADR-004：页眉页脚采用裁切并允许用户调参

原因：自动判定易误删；桌面端可通过预览调参获得更高可靠性。

---

## 2.11 与后续文档的关系

* 《03_数据结构与IR规范》：定义 IR 的字段、约束、校验规则与坐标体系
* 《06_PDF渲染与图像预处理》：落实渲染与预处理参数、缓存策略
* 《07_表格检测与单元格分割算法》：落实 bbox 检测、单元格分割、rowspan/colspan 推断算法细节
* 《08_Gemini集成与提示词》：落实 API 封装与两类 prompt 的最终版本
* 《10_Word生成_OpenXML实现》：落实页面尺寸映射、字体样式、表格合并实现
* 《09_结果校验_重试_降级策略》：落实失败分类、重试条件、降级输出规则
